#pragma once

#include <cstddef>

namespace std {

  template<typename ...>
    using void_t = void;

  template<typename T, T v>
    struct integral_constant {
      static constexpr T value = v;
      using value_type = T;
      using type = integral_constant;

      constexpr operator value_type() const noexcept { return value; }
      constexpr value_type operator()() const noexcept { return value; }
    };

  template<bool v>
  using bool_constant = integral_constant<bool, v>;

  using true_type = bool_constant<true>;
  using false_type = bool_constant<false>;

  template<typename T>
    struct using_type {
      using type = T;
    };

  // remove_const
  template<typename T>
    struct remove_const : using_type<T> { };

  template<typename T>
    struct remove_const<const T> : using_type<T> { };

  template<typename T>
    using remove_const_t = typename remove_const<T>::type;

  // remove_volatile
  template<typename T>
    struct remove_volatile : using_type<T> { };

  template<typename T>
    struct remove_volatile<volatile T> : using_type<T> { };

  template<typename T>
    using remove_volatile_t = typename remove_volatile<T>::type;

  // remove_cv
  template<typename T>
    struct remove_cv : using_type<remove_volatile_t<remove_const_t<T>>> { };

  template<typename T>
    using remove_cv_t = typename remove_cv<T>::type;

  // remove_reference
  template<typename T>
    struct remove_reference : using_type<T> { };

  template<typename T>
    struct remove_reference<T&> : using_type<T> { };

  template<typename T>
    struct remove_reference<T&&> : using_type<T> { };

  template<typename T>
    using remove_reference_t = typename remove_reference<T>::type;

  // remove_cvref
  template<typename T>
    struct remove_cvref : using_type<remove_cv_t<remove_reference_t<T>>> { };

  template<typename T>
    using remove_cvref_t = typename remove_cvref<T>::type;

  // conditional
  template<bool Cond, typename True_type, typename False_type>
    struct conditional : using_type<True_type> { };

  template<typename True_type, typename False_type>
    struct conditional<false, True_type, False_type> : using_type<False_type> { };

  template<bool B, typename T, typename F>
    using conditional_t = typename conditional<B, T, F>::type;

  // is_same
  template<typename T, typename U>
    struct is_same : false_type { };

  template<typename T>
    struct is_same<T, T> : true_type { };

  template<typename T, typename U>
    inline constexpr bool is_same_v = is_same<T, U>::value;

  // is_const
  template<typename T>
    struct is_const : false_type { };

  template<typename T>
    struct is_const<const T> : true_type { };

  template<typename T>
    inline constexpr bool is_const_v = is_const<T>::value;

  // is_reference
  template<typename T>
    struct is_reference : false_type { };

  template<typename T>
    struct is_reference<T&> : true_type { };

  template<typename T>
    struct is_reference<T&&> : true_type { };

  template<typename T>
    inline constexpr bool is_reference_v = is_reference<T>::value;

  // is_function
  template<typename T>
    struct is_function : bool_constant<!is_const_v<T const> && !is_reference_v<T>> {  };

  template<typename T>
    inline constexpr bool is_function_v = is_function<T>::value;

  // is_integral
  template<typename T>
    void operator+(T);

  template <typename T, typename = void>
    struct is_integral : false_type { };

  template <typename T>
    struct is_integral<T, void_t<decltype(+T{})&, decltype(T{} % 1)>> : true_type { };

  template<typename T>
    inline constexpr bool is_integral_v = is_integral<T>::value;

  // is_arithmetic
  template<typename T, typename = void>
    struct is_arithmetic : false_type { };

  template<typename T>
    struct is_arithmetic<T, void_t<decltype(T{} * T{}), decltype(+T{})&>> : true_type { };

  template<typename T>
    inline constexpr bool is_arithmetic_v = is_arithmetic<T>::value;

} // namespace std
