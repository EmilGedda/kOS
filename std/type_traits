#pragma once

#include <cstddef>

namespace std {

  template<typename T, T v>
    struct integral_constant {
      static constexpr T value = v;
      using value_type = T;
      using type = integral_constant;

      constexpr operator value_type() const noexcept { return value; }
      constexpr value_type operator()() const noexcept { return value; }
    };

  template<bool v>
  using bool_constant = integral_constant<bool, v>;

  using true_type = bool_constant<true>;
  using false_type = bool_constant<false>;


  template<bool cond, typename T_true, typename T_false>
    struct conditional { 
      using type = T_true;
    };

  template<typename T_true, typename T_false>
    struct conditional<false, T_true, T_false> {
      using type = T_false;
    };

  // is_same
  template<typename T, typename U>
    struct is_same       : false_type { };

  template<typename T>
    struct is_same<T, T> : true_type { };

  template<typename T, typename U>
    inline constexpr bool is_same_v = is_same<T, U>::value;

  // is_const
  template<typename T>
    struct is_const          : false_type { };

  template<typename T>
    struct is_const<const T> : true_type { };

  template<typename T>
    inline constexpr bool is_const_v = is_const<T>::value;

  // is_reference
  template<typename T>
    struct is_reference      : false_type { };

  template<typename T>
    struct is_reference<T&>  : true_type { };

  template<typename T>
    struct is_reference<T&&> : true_type { };

  template<typename T>
    inline constexpr bool is_reference_v = is_reference<T>::value;

  // is_function
  template<typename T>
    struct is_function : bool_constant<!is_const_v<T const> && !is_reference_v<T>> {  };

} // namespace std
